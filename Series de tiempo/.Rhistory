polyroot(c(1, -1, 1/4))
# Simulation using "arima.sim" function in R.
set.seed(12345)
y_ar2 <- arima.sim(model = list(order = c(2,0,0), ar = c(1, -0.25)), n = 500)
par(mfrow=c(1,1))
plot(y_ar2, ylab = "y(t) = y(t-1) - 0.25 y(t-2) + e(t)")
#-------------------------------------------------------------
# Estimation of model using ar function
#------------------------------------------------------------
md_ar <- ar(y_ar2)
md_ar
# We can use "arima" function for estimate ar model:
md_ar <- arima(y_ar2, order = c(2,0,0), method = "ML")
md_ar
#------------------------------------------------------------
# Unit root tests: AR(2) model
#-----------------------------------------------------------
# Augmented Dickey-Fuller Test
adf.test(y_ar2)
# Phillips-Perron Unit Root Test
pp.test(y_ar2)
# KPSS test
kpss.test(y_ar2)
#-----------------------------------------------------------
# ACF and PACF: AR(2) model
#-----------------------------------------------------------
par(mfrow=c(1,2))
acf(y_ar2)
pacf(y_ar2)
#-------------------------------------------------------------
# Simulated data for MA(2) model with parameters 0.5 and -0.3
#--------------------------------------------------------------
polyroot(c(1, -0.5, 0.3))
set.seed(12345)
y_ma2 <- arima.sim(model = list(order = c(0, 0, 2), ma = c(0.5, -0.3)), n = 500)
par(mfrow=c(1,1))
plot(y_ma2, xlab = "Time", ylab = "y(t) = 0.5e(t) - 0.3e(t)")
#----------------------------------------------------------
# estimation of model using arima function
#----------------------------------------------------------
md_ma <- arima(y_ma2, order = c(0,0,2), method = "ML")
md_ma
#-------------------------------------------------------------
# Unit root tests
#-------------------------------------------------------------
# Augmented Dickey-Fuller Test
adf.test(y_ma2)
# Phillips-Perron Unit Root Test
pp.test(y_ma2)
# KPSS test
kpss.test(y_ma2)
#---------------------------------------------------------
# ACF and PACF: MA(2) model
#---------------------------------------------------------
par(mfrow=c(1,2))
acf(y_ma2)
pacf(y_ma2)
#------------------------------------------------------
# What is the best model?
#------------------------------------------------------
arima(y_ma2, order = c(0, 0, 1), include.mean = FALSE)
arima(y_ma2, order = c(0, 0, 2), include.mean = FALSE)
arima(y_ma2, order = c(0, 0, 3), include.mean = FALSE)
AIC_ma <- NULL
AIC_ma[1] <- AIC(arima(y_ma2, order = c(0, 0, 1), include.mean = FALSE))
AIC_ma[2] <- AIC(arima(y_ma2, order = c(0, 0, 2), include.mean = FALSE))
AIC_ma[3] <- AIC(arima(y_ma2, order = c(0, 0, 3), include.mean = FALSE))
AIC_ma
min(AIC_ma)
#=============================================================
# Simulated data for ARMA(1,2) model
#=============================================================
set.seed(12345)
sim_arma <- arima.sim(model = list(order(1,0,2), ar = c(0.7), ma = c(0.5,-0.3)),
n = 500)
par(mfrow=c(1,1))
plot(sim_arma, ylab = "Value")
#------------------------------------------------------------
# Unit root tests
#-----------------------------------------------------------
# Augmented Dickey-Fuller Test
adf.test(sim_arma)
# Phillips-Perron Unit Root Test
pp.test(sim_arma)
# KPSS test
kpss.test(sim_arma)
#--------------------------------------------------------
# Estimation
#--------------------------------------------------------
arma_md <- arima(sim_arma, order = c(1,0,2))
arma_md
#---------------------------------------------------------
# ACF and PACF
#---------------------------------------------------------
par(mfrow=c(1,2))
acf(sim_arma)
pacf(sim_arma)
#----------------------------------------------------------
# Manual tuning of the ARMA model
#----------------------------------------------------------
AIC_model <- NULL
p=3  # Order of AR that you want check
q=3  # Order of MA that you want check
# The vector AIC_model will have the AIC value of each model
# As p=0,1,2,3 and q=0,1,2,3, we have 4*4-1 = 15 cases.
for(i in 1:p){
for(j in 1:q){
AIC_model[j] <- AIC(arima(sim_arma, order = c(0, 0, j), include.mean = FALSE))
AIC_model[i+p] <- AIC(arima(sim_arma, order = c(i, 0, 0), include.mean = FALSE))
AIC_model[i+2*p] <- AIC(arima(sim_arma, order = c(i, 0, 1), include.mean = FALSE))
AIC_model[i+3*p] <- AIC(arima(sim_arma, order = c(i, 0, 2), include.mean = FALSE))
AIC_model[i+4*p] <- AIC(arima(sim_arma, order = c(i, 0, 3), include.mean = FALSE))
}
}
# k is the position of vector AIC_model with the minimum value
k <- which(AIC_model == min(AIC_model))
#
if(k > p ) {
Q <- k %/% p
r <- k %% p
if (r == 0){
p_opt <- p
q_opt <- Q - 2
}else {
p_opt <- r
q_opt <- Q - 1
}
} else {
p_opt <- 0
q_opt <- k
}
# the p and q values for model with minimum AIC.
p_opt
q_opt
#----------------------------------------------------------------------
# Estimate the ARIMA model with p_opt, q_opt and d selected
#-----------------------------------------------------------------------
# Note: The use of the AIC or BIC score as a model selection criterion
# does not guarantee that the selected model (by either AIC or BIC score)
# does not violate the model assumptions.
#-----------------------------------------------------------------------
fit_arma <- arima(sim_arma, order = c(p_opt, 0, q_opt), include.mean = FALSE)
fit_arma
#-----------------------------------------------------------------------
# Ljung-Box test confirms that there is no autocorrelation
# left on the residualsâ€”with a p-value of 0.62, we cannot reject
# the null hypothesis that the residuals are white noise.
#---------------------------------------------------------------------
checkresiduals(fit_arma)
#------------------------------------------------------
# What is the best model? Choice the model with minimum AIC or BIC
#------------------------------------------------------
p_prop <- 5
q_prop <- 5
table_aic<-matrix(0,p_prop+1,q_prop+1)
table_bic <- matrix(0,p_prop+1,q_prop+1)
for (i in 0:p_prop) for (j in 0:q_prop) {
table_aic[i+1,j+1]<-AIC(arima(sim_arma, order=c(i,0,j)))
table_bic[i+1,j+1]<-BIC(arima(sim_arma, order=c(i,0,j)))
}
table_aic
table_bic
order_aic = which(table_aic == min(table_aic), arr.ind=TRUE)
order_bic = which(table_bic == min(table_bic), arr.ind=TRUE)
p_aic <- order_aic[1]-1
q_aic <- order_aic[2]-1
p_bic <- order_bic[1]-1
q_bic <- order_bic[2]-1
# the p and q values for model with minimum AIC.
p_aic
q_aic
# the p and q values for model with minimum BIC.
p_bic
q_bic
#----------------------------------------------------------
# What is the best model? Another approach
#---------------------------------------------------------
best_order <- c(0, 0, 0)
best_bic <- Inf
for (i in 0:5) for (j in 0:5) {
fit_bic <- BIC(arima(sim_arma, order = c(i, 0, j)))
if (fit_bic < best_bic) {
best_order <- c(i, 0, j)
best_bic <- fit_bic
}
}
best_order
best_bic
#------------------------------------------------------------------
# Estimate the ARIMA model with p_opt, q_opt and d selected
#------------------------------------------------------------------
fit_arma <- arima(sim_arma, order = c(p_bic, 0, q_bic), include.mean = FALSE)
fit_arma
fit_arma$sigma2
#--------------------------------------------------------------
# Plotting the characteristic roots
#--------------------------------------------------------------
autoplot(fit_arma)
#--------------------------------------------------------
# Forecasting AR, MA, and ARMA models
#------------------------------------------------------------
# Next 12 forecasted values
forecastedValues_0 <- forecast(fit_arma, 12)
forecastedValues_0
par(mfrow=c(1,1))
plot(forecastedValues_0, main = "Graph with forecasting",
col.main = "darkgreen")
#=======================================================
# Examples of simulation of ARIMA Models
# Time series
# Elaborated by: Manuel Correa Giraldo
#=======================================================
#-------------------------------------------------------
# Packages
#-------------------------------------------------------
install.packages("hrbrthemes")
install.packages("plotly")
install.packages("xts")
#-------------------------------------------------------
# Libraries
#-------------------------------------------------------
library(tseries)
library(forecast)
library(TSstudio)
library(readxl)
#-----------------------------------------------
# IPC Colombia: Data
#-----------------------------------------------
setwd("/Users/pablo4buitrago/Documents/EAFIT_Semestre9/Series de tiempo")
IPCCol <- read_excel("IPC 2000-2022.xlsx", sheet=1)
summary(IPCCol)
#------------------------------------------------
# Transform to time series format
#-------------------------------------------------
IPC.ts <- ts(IPCCol$Inflation_annual, start=c(2000, 1), end=c(2022, 11), frequency=12)
class(IPC.ts)
IPC.ts
# Check:
start(IPC.ts);end(IPC.ts);frequency(IPC.ts)
#---------------------------------------------------
# plot time series
#--------------------------------------------------
plot(IPC.ts, xlab ="Year", ylab="IPC")
#--------------------------------------------------
# Classical decomposition
#-------------------------------------------------
IPC_decompose <- decompose(IPC.ts, type = "multiplicative")
plot(IPC_decompose)
IPC_decompose <- decompose(IPC.ts, type = "additive")
plot(IPC_decompose)
#----------------------------------------------------
# We consider a subsample of the data series
#----------------------------------------------------
IPC.sample <- window(IPC.ts, start = c(2020, 1), end = c(2022, 11))
IPC.sample
plot(IPC.sample, xlab ="Year", ylab="IPC")
#-----------------------------------------------------
# Descriptive statistics
#-----------------------------------------------------
summary(IPC.sample)
#----------------------------------------------------
# Unit root tests
#----------------------------------------------------
# Augmented Dickey-Fuller Test
adf.test(IPC.sample)
# Phillips-Perron Unit Root Test
pp.test(IPC.sample)
# KPSS test
kpss.test(IPC.sample)
#----------------------------------------------------
# First differentiation of time series
#---------------------------------------------------
IPC.sample_d1 <- diff(IPC.sample)
#-----------------------------------------------------
# Plot
#-----------------------------------------------------
plot(IPC.sample_d1, type="l", xlab="Year", ylab="Diff IPC")
#-------------------------------------------------
# Unit root tests
#----------------------------------------------------
# Augmented Dickey-Fuller Test
adf.test(IPC.sample_d1)
# Phillips-Perron Unit Root Test
pp.test(IPC.sample_d1)
# KPSS test
kpss.test(IPC.sample_d1)
#----------------------------------------------------
# Second differentiation of time series
#---------------------------------------------------
IPC.sample_d2 <- diff(IPC.sample_d1)
#-----------------------------------------------------
# Plot
#-----------------------------------------------------
plot(IPC.sample_d2, type="l", xlab="Year", ylab="Diff IPC")
#-------------------------------------------------
# Unit root tests
#----------------------------------------------------
# Augmented Dickey-Fuller Test
adf.test(IPC.sample_d2)
# Phillips-Perron Unit Root Test
pp.test(IPC.sample_d2)
# KPSS test
kpss.test(IPC.sample_d2)
#----------------------------------------------------
# ACF and PACF plots
#-----------------------------------------------------
par(mfrow=c(1,2))
acf(IPC.sample_d1)
pacf(IPC.sample_d1)
#----------------------------------------------------
# ACF and PACF plots
#-----------------------------------------------------
par(mfrow=c(1,2))
acf(IPC.sample_d2)
pacf(IPC.sample_d2)
#---------------------------------------------------
# Best model
#----------------------------------------------------
best_order <- c(0, 0, 0)
best_bic <- Inf
for (i in 0:5) for (j in 0:5) {
fit_bic <- BIC(arima(IPC.sample_d2, order = c(i, 0, j)))
if (fit_bic < best_bic) {
best_order <- c(i, 0, j)
best_bic <- fit_bic
}
}
best_order
best_bic
#-----------------------------------------------------------
# Estimation
#-----------------------------------------------------------
fit_IPC <- arima(IPC.sample_d2, order = best_order, include.mean = FALSE)
summary(fit_IPC)
fit_IPC <- arima(IPC.sample, order = c(0,2,1), include.mean = FALSE)
summary(fit_IPC)
#------------------------------------------------------------
# the residuals are white noise?
#--------------------------------------------------------------
checkresiduals(fit_IPC)
#--------------------------------------------------------------
# Plotting the characteristic roots
#--------------------------------------------------------------
autoplot(fit_IPC)
#--------------------------------------------------------
# Forecasting
#------------------------------------------------------------
# Next 12 forecasted values (you choose this value)
forecastedValues_0 <- forecast(fit_IPC, 12)
forecastedValues_0 # print forecasted values
plot(forecastedValues_0, main = "Graph with forecasting",
col.main = "darkgreen")
#============================================================
# auto.arima function
#============================================================
fit_1 <- auto.arima(IPC.sample)
fit_1
# Next 12 forecasted values
forecastedValues_1 <- forecast(fit_1, 12)
forecastedValues_1
plot(forecastedValues_1, main = "Graph with forecasting",
col.main = "darkgreen")
#=======================================================
# Examples of simulation of ARIMA Models
# Time series
# Elaborated by: Manuel Correa Giraldo
#=======================================================
#--------------------------------------------------------
# Packages
#--------------------------------------------------------
install.packages("TSstudio")
install.packages("TSstudio")
#--------------------------------------------------------
# Libraries
#--------------------------------------------------------
library(TSstudio)
library(tseries)
library(forecast)
#--------------------------------------------------------
# Data
#--------------------------------------------------------
data("Coffee_Prices")
ts_info(Coffee_Prices)
robusta_price <- window(Coffee_Prices[,1], start = c(2000, 1))
#--------------------------------------------------------
# Plot
#--------------------------------------------------------
plot(robusta_price, type="l", xlab="Year", ylab="Price in USD")
robusta_price
#-----------------------------------------------------
# Descriptive statistics
#-----------------------------------------------------
summary(robusta_price)
#------------------------------------------------------------
# Box-Cox transformation
#------------------------------------------------------------
robusta_lambda <- BoxCox.lambda(robusta_price)
robusta_lambda
robusta_transform <- BoxCox(robusta_price, lambda = robusta_lambda)
BoxCox.lambda(robusta_transform)
plot(robusta_transform, type="l", xlab="Year", ylab="Price in USD")
#----------------------------------------------------
# Unit root tests
#----------------------------------------------------
# Augmented Dickey-Fuller Test
adf.test(robusta_price)
adf.test(robusta_transform)
# Phillips-Perron Unit Root Test
pp.test(robusta_price)
pp.test(robusta_transform)
# KPSS test
kpss.test(robusta_price)
kpss.test(robusta_transform)
#----------------------------------------------------
# Differentiation of time series
#---------------------------------------------------
robusta_price_d1 <- diff(robusta_price)
robusta_transform_d1 <- diff(robusta_transform)
#-----------------------------------------------------
# Plot
#-----------------------------------------------------
plot(robusta_price_d1, type="l", xlab="Year", ylab="Diff price in USD")
plot(robusta_transform_d1, type="l", xlab="Year", ylab="Diff price in USD")
#-------------------------------------------------
# Unit root tests
#----------------------------------------------------
# Augmented Dickey-Fuller Test
adf.test(robusta_price_d1)
adf.test(robusta_transform_d1)
# Phillips-Perron Unit Root Test
pp.test(robusta_price_d1)
pp.test(robusta_transform_d1)
# KPSS test
kpss.test(robusta_price_d1)
kpss.test(robusta_transform_d1)
#----------------------------------------------------
# ACF and PACF plots: robusta_price_d1
#-----------------------------------------------------
par(mfrow=c(1,2))
acf(robusta_price_d1)
pacf(robusta_price_d1)
#----------------------------------------------------
# ACF and PACF plots: robusta_transform_d1
#-----------------------------------------------------
par(mfrow=c(1,2))
acf(robusta_transform_d1)
pacf(robusta_transform_d1)
#----------------------------------------------------------
# What is the best model? for robusta_price_d1
#----------------------------------------------------------
best_order1 <- c(0, 0, 0)
best_bic1 <- Inf
for (i in 0:3) for (j in 0:3) {
fit_bic1 <- BIC(arima(robusta_price_d1, order = c(i, 0, j)))
if (fit_bic1 < best_bic1) {
best_order1 <- c(i, 0, j)
best_bic1 <- fit_bic1
}
}
best_order1
best_bic1
#----------------------------------------------------------
# What is the best model? for robusta_transform_d1
#----------------------------------------------------------
best_order2 <- c(0, 0, 0)
best_bic2 <- Inf
for (i in 0:3) for (j in 0:3) {
fit_bic2 <- BIC(arima(robusta_transform_d1, order = c(i, 0, j)))
if (fit_bic2 < best_bic2) {
best_order2 <- c(i, 0, j)
best_bic2 <- fit_bic2
}
}
best_order2
best_bic2
best_bic2
best_bic2
#-----------------------------------------------------------
# Estimation
#-----------------------------------------------------------
fit_price1 <- arima(robusta_price_d1, order = best_order1, include.mean = FALSE)
summary(fit_price1)
fit_price2 <- arima(robusta_transform_d1, order = best_order2, include.mean = FALSE)
summary(fit_price2)
fit_price <- arima(robusta_price, order = c(1, 1, 0), include.mean = FALSE)
summary(fit_price)
#------------------------------------------------------------
# the residuals are white noise?
#--------------------------------------------------------------
checkresiduals(fit_price)
#--------------------------------------------------------------
# Plotting the characteristic roots
#--------------------------------------------------------------
autoplot(fit_price)
#--------------------------------------------------------
# Forecasting
#------------------------------------------------------------
# Next 12 forecasted values (you choose this value)
forecastedValues_0 <- forecast(fit_price, 12)
forecastedValues_0 # print forecasted values
plot(forecastedValues_0, main = "Graph with forecasting",
col.main = "darkgreen")
#============================================================
# auto.arima function
#============================================================
fit_1 <- auto.arima(robusta_price)
fit_1
# Next 12 forecasted values
forecastedValues_1 <- forecast(fit_1, 12)
forecastedValues_1
plot(forecastedValues_1, main = "Graph with forecasting",
col.main = "darkgreen")
